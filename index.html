<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>断線利用レールループ生成ツール</title>
<link rel="icon" type="image/png" href="icon.png">
<style>
  * {
    box-sizing: border-box;
  }
  body {
    font-family: sans-serif;
    background: #f5f5f5;
    color: #222;
    margin: 0;
    padding: 10px;
    max-width: 100%;
    overflow-x: hidden;
  }
  h1 { 
    font-size: 18px; 
    margin-bottom: 10px;
    word-wrap: break-word;
  }
  #HowtoUse { margin-top: 30px; font-size: 24px; }
  label { display:block; margin-top:10px; }
  input,select,button {
    margin-top:5px; padding:5px 8px; font-size:14px;
    max-width: 100%;
  }
  input[type="number"] {
    width: 100%;
    max-width: 200px;
  }
  select {
    width: 100%;
    max-width: 200px;
  }
  button {
    margin-right: 5px;
    margin-bottom: 5px;
    cursor: pointer;
  }
  .button-group {
    margin-top: 10px;
  }
  #results { 
    margin-top:16px; 
    font-family: monospace; 
    white-space:pre-wrap; 
    font-size:16px;
    word-break: break-word;
  }
  
  @media (max-width: 600px) {
    body {
      padding: 5px;
    }
    h1 {
      font-size: 16px;
    }
    #HowtoUse {
      font-size: 20px;
    }
    button {
      font-size: 13px;
      padding: 8px 10px;
      margin-right: 3px;
      margin-bottom: 5px;
    }
    input, select {
      font-size: 16px;
    }
    #results {
      font-size: 12px;
    }
  }
  
  .collapsible {
    background-color: #e7e7e7;
    color: #222;
    cursor: pointer;
    padding: 10px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 14px;
    margin-top: 10px;
    border-radius: 4px;
  }
  
  .collapsible:hover {
    background-color: #ddd;
  }
  
  .collapsible:after {
    content: '\002B';
    color: #222;
    font-weight: bold;
    float: right;
    margin-left: 5px;
  }
  
  .collapsible.active:after {
    content: "\2212";
  }
  
  .content {
    padding: 0 18px;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.2s ease-out;
    background-color: #f9f9f9;
    border-radius: 0 0 4px 4px;
  }
  
  .content.show {
    max-height: 1000px;
    padding: 18px;
  }
  
  .checkbox-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 8px;
    margin-top: 10px;
  }
  
  @media (max-width: 600px) {
    .checkbox-group {
      grid-template-columns: 1fr;
      gap: 5px;
    }
  }
  
  .checkbox-item {
    display: flex;
    align-items: center;
  }
  
  .checkbox-item input[type="checkbox"] {
    margin-right: 5px;
    margin-top: 0;
  }
  
  .section-title {
    font-weight: bold;
    margin: 15px 0 10px 0;
    padding: 5px;
    background-color: #ddd;
    border-radius: 3px;
  }
  
  .special-note {
    font-size: 12px;
    color: #666;
    font-style: italic;
    margin-left: 20px;
  }

  .rail-limit-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 10px;
    margin-top: 10px;
  }
  
  .rail-limit-item {
    display: flex;
    flex-direction: column;
  }
  
  .rail-limit-item label {
    font-size: 13px;
    margin-bottom: 3px;
  }
  
  .rail-limit-item input[type="number"] {
    width: 100%;
    max-width: none;
  }
  
  @media (max-width: 600px) {
    .rail-limit-group {
      grid-template-columns: 1fr;
      gap: 8px;
    }
  }

  .calculating {
    color: #666;
    font-style: italic;
  }

  #calc.disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }
</style>
</head>
<body>
<h1>断線利用レールループ生成ツール</h1>
<small>断線を使用したレールループを生成してくれます。<br>使い方は<a href="#HowtoUse">こちら</a></small>
<label>目標値[f]：
  <input type="number" id="target" value="300">
</label>
<label>最大表示数：
  <input type="number" id="limit" value="100">
</label>
<label>モード選択：
  <select id="mode">
    <option value="loop">周回モード</option>
    <option value="roundtrip">往復モード</option>
  </select>
</label>

<button type="button" class="collapsible">高度な設定</button>
<div class="content">
  <div class="section-title">基本レールの使用回数指定</div>
  <small>各レールの使用回数を指定します（0または空白で指定なし）</small>
  <div class="rail-limit-group">
    <div class="rail-limit-item">
      <label for="limit-s">s - 直線レール (21f)</label>
      <input type="number" id="limit-s" value="0" min="0">
    </div>
    <div class="rail-limit-item">
      <label for="limit-d">d - 斜線レール (30f)</label>
      <input type="number" id="limit-d" value="0" min="0">
    </div>
    <div class="rail-limit-item">
      <label for="limit-c">c - 曲線レール (36f)</label>
      <input type="number" id="limit-c" value="0" min="0">
    </div>
  </div>
  
  <div class="section-title" style="margin-top: 20px;">使用するレール・断線の種類</div>
  使用するレールまたは断線の種類を選択します。<br>
  <div class="section-title">基本レール</div>
  <div class="checkbox-group">
    <div class="checkbox-item">
      <input type="checkbox" id="check-s" checked>
      <label for="check-s">s - 直線レール (21f)</label>
    </div>
    <div class="checkbox-item">
      <input type="checkbox" id="check-d" checked>
      <label for="check-d">d - 斜線レール (30f)</label>
    </div>
    <div class="checkbox-item">
      <input type="checkbox" id="check-c" checked>
      <label for="check-c">c - 曲線レール (36f)</label>
    </div>
  </div>
  
  <div id="mode1-section">
    <div class="section-title">断線（周回モード）</div>
    <div id="mode1-checkboxes" class="checkbox-group">
      <div class="checkbox-item">
        <input type="checkbox" id="check-↓sG1" checked>
        <label for="check-↓sG1">↓sG1 (31f) </label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↓sG2" checked>
        <label for="check-↓sG2">↓sG2 (38f)</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↓sG3" checked>
        <label for="check-↓sG3">↓sG3 (45f)</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↓sG4">
        <label for="check-↓sG4">↓sG4 (50f)</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↓sG5">
        <label for="check-↓sG5">↓sG5 (56f)</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↓sG6">
        <label for="check-↓sG6">↓sG6 (60f)</label>
      </div>
      <br>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↑sG1" checked>
        <label for="check-↑sG1">↑sG1 (30f) ※座標依存あり</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↑sG2" checked>
        <label for="check-↑sG2">↑sG2 (39f)</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-↑sG3" checked>
        <label for="check-↑sG3">↑sG3 (54f)</label>
      </div>
    </div>
  </div>
  
  <div id="mode2-section" style="display:none;">
    <div class="section-title">断線（往復モード）</div>
    <div id="mode2-checkboxes" class="checkbox-group">
      <div class="checkbox-item">
        <input type="checkbox" id="check-sG1" checked>
        <label for="check-sG1">sG1 (61f) ※座標依存あり</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-sG2" checked>
        <label for="check-sG2">sG2 (77f)</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-sG3" checked>
        <label for="check-sG3">sG3 (99f)</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="check-sF" checked>
        <label for="check-sF">sF (132f)</label>
      </div>
    </div>
  </div>
</div>

<div class="button-group">
  <button id="sortBtn" disabled>s-d差でソート</button>
  <button id="sortCBtn" disabled>c個数でソート</button>
  <button id="sortModeBtn" disabled>断線の個数でソート</button>
  <button id="filterBtn" disabled>断線が1種類以下で絞込</button>
  <button id="resetBtn" disabled>リセット</button>
  <br><button id="calc">生成</button>
  <button id="stopBtn" disabled>停止</button>
</div>
<div id="results"></div>
<br>
<h1 id="HowtoUse">使い方</h1>
目標値に希望の値を入力し、モードを選択して「生成」ボタンを押すと結果が表示されます。<br>
目標値が大きくなるにつれ計算量も増えるため、最大表示数を適宜調整してください。<br>
生成中は「停止」ボタンで計算を中断できます。<br>
<br>
<h2>基本レールの使用回数指定</h2>
高度な設定で、各基本レール（s、d、c）の使用回数を指定できます。<br>
0または空白を入力すると指定なしとして扱われます。<br>
また、使用する断線の種類も指定できます。<br>
<br>
<h2>レール(断線)種類</h2>
<h3>基本レール</h3>
s = 直線レール<br>
d = 斜線レール<br>
c = 曲線レール<br>
<h3>周回モード</h3>
↓sG1 = ↓G1-直線レール<br>
↓sG2 = ↓G2-直線レール<br>
↓sG3 = ↓G3-直線レール<br>
↓sG4 = ↓G4-直線レール<br>
↓sG5 = ↓G5-直線レール<br>
↓sG6 = ↓G6-直線レール<br>
↑sG1 = ↑G1-直線レール<br>
↑sG2 = ↑G2-直線レール<br>
↑sG3 = ↑G3-直線レール<br>
<h3>往復モード</h3>
sG1 = G1-直線レール<br>
sG2 = G2-直線レール<br>
sG3 = G3-直線レール<br>
sF = 直線レール-F<br>
<br>
<h2>ソート、絞り込みについて</h2>
ソート、絞り込みは「生成」ボタンを押した後に使用可能になります。<br>
<button>s-d差でソート</button> - sとdの個数の差の絶対値が小さい順にソートします。<br>
<button>c個数でソート</button> - cの個数が少ない順にソートします。<br>
<button>断線の個数でソート</button> - 断線の個数の合計が少ない順にソートします。<br>
<button>断線が1種類以下で絞込</button> - 断線が1種類以下の組み合わせに絞り込みます。<br>
<button>リセット</button> - ソート、絞り込み前の状態に戻します。<br>
<br>
<h2>その他</h2>
<b>↑G1-直線レール</b>と<b>G1-直線レール</b>は<b>座標によって遅延(f)が変わり</b>ます。<br>
これらの断線が<b>16≦y≦64</b>で使用される場合、他のエリアより<b>1fだけ早く</b>なります。ご利用は計画的に。<br>
<h3>URLなど</h3>
<a href="https://sites.google.com/view/loopingmusiclab" target="_blank" rel="noopener noreferrer">演奏コース研究会</a><br>
<br>
先人の研究に感謝します。感謝してもしきれません。
<script>
const baseItems = [
  {name:"s", value:21, mode:0},
  {name:"d", value:30, mode:0},
  {name:"c", value:36, mode:0},
  {name:"↓sG1", value:31, mode:1},
  {name:"↓sG2", value:38, mode:1},
  {name:"↓sG3", value:45, mode:1},
  {name:"↓sG4", value:50, mode:1},
  {name:"↓sG5", value:56, mode:1},
  {name:"↓sG6", value:60, mode:1},
  {name:"↑sG1", value:30, mode:1},
  {name:"↑sG2", value:39, mode:1},
  {name:"↑sG3", value:54, mode:1},
  {name:"sG1", value:61, mode:2},
  {name:"sG2", value:77, mode:2},
  {name:"sG3", value:99, mode:2},
  {name:"sF", value:132, mode:3}
];

let currentResults = [];
let displayedResults = [];
let isCalculating = false;
let shouldStop = false;

// 折りたたみ機能
document.addEventListener('DOMContentLoaded', function() {
  const coll = document.getElementsByClassName("collapsible");
  for (let i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      const content = this.nextElementSibling;
      content.classList.toggle("show");
    });
  }
});

// モード変更時のチェックボックス表示切り替え
document.getElementById('mode').addEventListener('change', function() {
  const mode = this.value;
  const mode1Section = document.getElementById('mode1-section');
  const mode2Section = document.getElementById('mode2-section');
  
  if (mode === 'loop') {
    mode1Section.style.display = 'block';
    mode2Section.style.display = 'none';
  } else {
    mode1Section.style.display = 'none';
    mode2Section.style.display = 'block';
  }
});

// 選択された基本レールを取得する関数
function getSelectedBaseItems() {
  const selected = [];
  baseItems.filter(item => item.mode === 0).forEach(item => {
    const checkbox = document.getElementById(`check-${item.name}`);
    if (checkbox && checkbox.checked) {
      selected.push(item);
    }
  });
  return selected;
}

// 選択された断線レールを取得する関数
function getSelectedMode1Items() {
  const selected = [];
  baseItems.filter(item => item.mode === 1).forEach(item => {
    const checkbox = document.getElementById(`check-${item.name}`);
    if (checkbox && checkbox.checked) {
      selected.push(item);
    }
  });
  return selected;
}

function getSelectedMode2Items() {
  const selected = [];
  baseItems.filter(item => item.mode === 2).forEach(item => {
    const checkbox = document.getElementById(`check-${item.name}`);
    if (checkbox && checkbox.checked) {
      selected.push(item);
    }
  });
  return selected;
}

// sFが選択されているかチェック
function isSFSelected() {
  const checkbox = document.getElementById('check-sF');
  return checkbox && checkbox.checked;
}

// UIの状態を更新
function updateUIState(calculating) {
  const calcBtn = document.getElementById('calc');
  const stopBtn = document.getElementById('stopBtn');
  const buttons = [
    document.getElementById('sortBtn'),
    document.getElementById('sortCBtn'),
    document.getElementById('sortModeBtn'),
    document.getElementById('filterBtn'),
    document.getElementById('resetBtn')
  ];
  
  if (calculating) {
    calcBtn.disabled = true;
    calcBtn.classList.add('disabled');
    calcBtn.textContent = '計算中...';
    stopBtn.disabled = false;
    buttons.forEach(btn => btn.disabled = true);
  } else {
    calcBtn.disabled = false;
    calcBtn.classList.remove('disabled');
    calcBtn.textContent = '生成';
    stopBtn.disabled = true;
    const hasResults = currentResults.length > 0;
    buttons.forEach(btn => btn.disabled = !hasResults);
  }
}

// 停止ボタンのイベントリスナー
document.getElementById('stopBtn').addEventListener('click', () => {
  if (isCalculating) {
    shouldStop = true;
    document.getElementById('stopBtn').textContent = '停止中...';
    document.getElementById('stopBtn').disabled = true;
  }
});

document.getElementById('calc').addEventListener('click', async () => {
  if (isCalculating) return;
  
  const target = Number(document.getElementById('target').value);
  const limit  = Number(document.getElementById('limit').value);
  const mode   = document.getElementById('mode').value;
  
  // 選択された基本アイテム（mode:0）を取得
  let items = getSelectedBaseItems().map(it=>{
    if (mode === "roundtrip") {
      return {...it, value: it.value * 2};
    }
    return {...it};
  });
  
  // 選択された断線レールを追加
  if (mode === "loop") {
    items = items.concat(getSelectedMode1Items());
  } else if (mode === "roundtrip") {
    items = items.concat(getSelectedMode2Items());
    // sFが選択されている場合は追加（往復モードのみ）
    if (isSFSelected()) {
      items.push({name:"sF", value:132, mode:3});
    }
  }
  
  isCalculating = true;
  shouldStop = false;
  updateUIState(true);
  document.getElementById('results').textContent = '計算を開始しています...';
  
  try {
    currentResults = await findCombinationsAsync(target, limit, items);
    displayedResults = [...currentResults];
    
    // 計算完了時の最終表示
    const out = document.getElementById('results');
    if (currentResults.length === 0) {
      out.textContent = shouldStop ? '計算が停止されました。該当する組み合わせは見つかりませんでした。' : '該当する組み合わせはありません。';
    } else {
      const statusText = shouldStop ? '計算が停止されました。' : '計算完了！';
      out.textContent = `${statusText} ${currentResults.length}件の結果が見つかりました。\n\n` + 
                       currentResults.map(r=>formatCompact(r)).join("\n");
    }
  } catch (error) {
    document.getElementById('results').textContent = 'エラーが発生しました: ' + error.message;
  } finally {
    isCalculating = false;
    shouldStop = false;
    document.getElementById('stopBtn').textContent = '停止';
    updateUIState(false);
  }
});

document.getElementById('sortModeBtn').addEventListener('click', ()=>{
  if(displayedResults.length === 0) return;
  
  displayedResults = [...displayedResults].sort((a, b) => {
    const mode123ItemsA = baseItems.filter(item => item.mode === 1 || item.mode === 2 || item.mode === 3);
    const totalCountA = mode123ItemsA.reduce((sum, item) => sum + (a[item.name] || 0), 0);
    
    const mode123ItemsB = baseItems.filter(item => item.mode === 1 || item.mode === 2 || item.mode === 3);
    const totalCountB = mode123ItemsB.reduce((sum, item) => sum + (b[item.name] || 0), 0);
    
    return totalCountA - totalCountB;
  });
  
  render(displayedResults);
});

document.getElementById('sortCBtn').addEventListener('click', ()=>{
  if(displayedResults.length === 0) return;
  
  displayedResults = [...displayedResults].sort((a, b) => {
    const cCountA = a["c"] || 0;
    const cCountB = b["c"] || 0;
    return cCountA - cCountB;
  });
  
  render(displayedResults);
});

document.getElementById('filterBtn').addEventListener('click', ()=>{
  if(displayedResults.length === 0) return;
  
  displayedResults = displayedResults.filter(result => {
    const mode123Items = baseItems.filter(item => item.mode === 1 || item.mode === 2 || item.mode === 3);
    const usedCount = mode123Items.filter(item => (result[item.name] || 0) > 0).length;
    return usedCount <= 1;
  });
  
  render(displayedResults);
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  if(currentResults.length === 0) return;
  
  displayedResults = [...currentResults];
  render(displayedResults);
});

document.getElementById('sortBtn').addEventListener('click', ()=>{
  if(displayedResults.length === 0) return;
  
  displayedResults = [...displayedResults].sort((a, b) => {
    const sCountA = a["s"] || 0;
    const dCountA = a["d"] || 0;
    const diffA = Math.abs(sCountA - dCountA);
    
    const sCountB = b["s"] || 0;
    const dCountB = b["d"] || 0;
    const diffB = Math.abs(sCountB - dCountB);
    
    return diffA - diffB;
  });
  
  render(displayedResults);
});

function render(results){
  const out = document.getElementById('results');
  if(results.length===0){
    out.textContent = '該当する組み合わせはありません。';
    return;
  }
  out.textContent = results.map(r=>formatCompact(r)).join("\n");
}

function formatCompact(r){
  return Object.entries(r)
    .filter(([k,v])=>v>0)
    .map(([k,v])=>`${k}×${v}`)
    .join(', ');
}

// 非同期版の組み合わせ検索関数
async function findCombinationsAsync(target, limit, items) {
  return new Promise((resolve, reject) => {
    const results = [];
    const counts = {};
    const sItem = items.find(i => i.name === "s");
    let iterationCount = 0;
    let lastDisplayUpdate = 0;
    const YIELD_INTERVAL = 10000;
    const DISPLAY_INTERVAL = 100;
    
    // 基本レールの使用回数制限を取得
    const railLimits = {
      s: Number(document.getElementById('limit-s').value) || Infinity,
      d: Number(document.getElementById('limit-d').value) || Infinity,
      c: Number(document.getElementById('limit-c').value) || Infinity
    };
    
    function updateDisplay() {
      if (results.length > lastDisplayUpdate) {
        displayedResults = [...results];
        render(displayedResults);
        lastDisplayUpdate = results.length;
        
        const out = document.getElementById('results');
        out.textContent = `計算中... (${results.length}/${limit}件見つかりました)\n\n` + 
                         results.map(r=>formatCompact(r)).join("\n");
      }
    }
    
    function dfs(idx, remaining) {
      if (shouldStop) {
        return Promise.resolve();
      }
      
      iterationCount++;
      
      if (iterationCount % YIELD_INTERVAL === 0) {
        return new Promise(resolve => {
          setTimeout(() => {
            resolve(dfsSync(idx, remaining));
          }, 0);
        });
      }
      
      return dfsSync(idx, remaining);
    }
    
    function dfsSync(idx, remaining) {
      if (shouldStop || results.length >= limit) return Promise.resolve();
      
      if (idx === items.length) {
        if (remaining === 0) {
          const sCount = counts["s"] || 0;
          const dCount = counts["d"] || 0;
          const cCount = counts["c"] || 0;
          
          // 基本レールの使用回数指定チェック
          if (railLimits.s !== Infinity && sCount !== railLimits.s) return Promise.resolve();
          if (railLimits.d !== Infinity && dCount !== railLimits.d) return Promise.resolve();
          if (railLimits.c !== Infinity && cCount !== railLimits.c) return Promise.resolve();
          
          const m1sum = items.filter(i => i.mode === 1).reduce((sum, i) => sum + (counts[i.name] || 0), 0);
          const m2sum = items.filter(i => i.mode === 2).reduce((sum, i) => sum + (counts[i.name] || 0), 0);
          const m3sum = items.filter(i => i.mode === 3).reduce((sum, i) => sum + (counts[i.name] || 0), 0);
          
          if (m3sum > 1) return Promise.resolve();
          
          const normalMode2Sum = m2sum;
          const constraintSum = m1sum + normalMode2Sum;
          
          if (m1sum <= 4 && m2sum <= 2 && constraintSum <= sCount - 1) {
            results.push({ ...counts });
            
            if (results.length % DISPLAY_INTERVAL === 0 || results.length >= limit) {
              updateDisplay();
            }
          }
        }
        return Promise.resolve();
      }
      
      const item = items[idx];
      let max = Math.floor(remaining / item.value);
      
      if (item.mode === 3) {
        max = Math.min(max, 1);
      }
      
      // 基本レールの使用回数指定がある場合は、その回数に固定
      if (railLimits[item.name] !== undefined && railLimits[item.name] !== Infinity) {
        const exactCount = railLimits[item.name];
        // 指定回数が計算可能範囲内かチェック
        if (exactCount <= max) {
          counts[item.name] = exactCount;
          return dfs(idx + 1, remaining - exactCount * item.value);
        } else {
          // 指定回数が使用不可能な場合はスキップ
          counts[item.name] = 0;
          return Promise.resolve();
        }
      }
      
      return processRange(idx, remaining, item, max, 0);
    }
    
    async function processRange(idx, remaining, item, max, n) {
      if (shouldStop || n > max || results.length >= limit) {
        counts[item.name] = 0;
        return;
      }
      
      counts[item.name] = max - n;
      const result = await dfs(idx + 1, remaining - (max - n) * item.value);
      
      if (result instanceof Promise) {
        await result;
      }
      
      return processRange(idx, remaining, item, max, n + 1);
    }
    
    dfs(0, target).then(() => {
      updateDisplay();
      resolve(results);
    }).catch(reject);
  });
}
</script>
</body>
</html>
